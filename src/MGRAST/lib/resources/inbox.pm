package resources::inbox;

use strict;
use warnings;
no warnings('once');

use POSIX qw(strftime);
use HTTP::Request::StreamingUpload;
use HTTP::Headers;
use LWP::UserAgent;
use File::Basename;
use Data::Dumper;
use Digest::MD5 qw(md5 md5_hex md5_base64);

use Conf;
use MGRAST::Metadata;
use parent qw(resources::resource);

# Override parent constructor
sub new {
    my ($class, @args) = @_;

    # Call the constructor of the parent class
    my $self = $class->SUPER::new(@args);
    
    # Add name / attributes
    $self->{name} = "inbox";
    $self->{base_attr} = {
        'id'        => ['string', "user id"],
        'user'      => ['string', "user login"],
        'status'    => ['string', "status message"],
        'timestamp' => ['string', "timestamp for return of this query"]
    };
    $self->{stat_attr} = {%{$self->{base_attr}}, ('stats_info' => ['hash', 'key value pairs describing file info'])};
    $self->{id_attr} = {%{$self->{base_attr}}, ('awe_id' => ['string', "url/id of awe job" ])};
    $self->{states} = ["completed", "deleted", "suspend", "in-progress", "pending", "queued"];
    return $self;
}

# resource is called without any parameters
# this method must return a description of the resource
sub info {
    my ($self) = @_;
    my $content = {
        'name' => $self->name,
        'url' => $self->cgi->url."/".$self->name,
        'description' => "inbox receives user inbox data upload, requires authentication, see http://blog.metagenomics.anl.gov/mg-rast-v3-2-faq/#api_submission for details",
        'type' => 'object',
        'documentation' => $self->cgi->url.'/api.html#'.$self->name,
        'requests' => [
            { 'name'        => "info",
              'request'     => $self->cgi->url."/".$self->name,
              'description' => "Returns description of parameters and attributes.",
              'method'      => "GET",
              'type'        => "synchronous",  
              'attributes'  => "self",
              'parameters'  => {
                  'options'  => {},
                  'required' => {},
                  'body'     => {}
              }
            },
            { 'name'        => "view",
              'request'     => $self->cgi->url."/".$self->name,
              'description' => "lists the contents of the user inbox",
              'example'     => [ 'curl -X GET -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'"',
                  			     'lists the contents of the user inbox, auth is required' ],
              'method'      => "GET",
              'type'        => "synchronous",  
              'attributes'  => {
                  'id'        => [ 'string', "user id" ],
                  'user'      => [ 'string', "user login" ],
                  'timestamp' => [ 'string', "timestamp for return of this query" ],
                  'files'     => [ 'list', [ 'object', [
                                                { 'filename'  => [ 'string', "path of file from within user inbox" ],
                                                  'filesize'  => [ 'string', "disk size of file in bytes" ],
                                                  'checksum'  => [ 'string', "md5 checksum of file"],
                                                  'timestamp' => [ 'string', "timestamp of file" ]
                                                }, "list of file objects"] ] ],
                  'url'       => [ 'uri', "resource location of this object instance" ]
              },
              'parameters'  => {
                  'options'  => { "uuid" => [ "string", "RFC 4122 UUID for file" ] },
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "view_pending",
              'request'     => $self->cgi->url."/".$self->name."/pending",
              'description' => "view status of AWE inbox actions",
              'example'     => [ 'curl -X GET -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/pending?queued&completed"',
                                 "rename file 'sequences.fastq' in user inbox, auth is required" ],
              'method'      => "GET",
              'type'        => "synchronous",
              'attributes'  => $self->{base_attr},
              'parameters'  => {
                  'options'  => { map { $_, ["boolean", "If true show the given state"] } @{$self->{states}} },
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "upload",
              'request'     => $self->cgi->url."/".$self->name,
              'description' => "receives user inbox data upload",
              'example'     => [ 'curl -X POST -H "auth: auth_key" -F "upload=@sequences.fastq" "'.$self->cgi->url."/".$self->name.'"',
                    			 "upload file 'sequences.fastq' to user inbox, auth is required" ],
              'method'      => "POST",
              'type'        => "synchronous",
              'attributes'  => $self->{base_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => { "upload" => ["file", "file to upload to inbox"] }
              }
            },
            { 'name'        => "rename",
              'request'     => $self->cgi->url."/".$self->name."/{UUID}",
              'description' => "rename indicated file from inbox",
              'example'     => [ 'curl -X PUT -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/cfb3d9e1-c9ba-4260-95bf-e410c57b1e49"',
                                 "rename file 'sequences.fastq' in user inbox, auth is required" ],
              'method'      => "PUT",
              'type'        => "synchronous",
              'attributes'  => $self->{base_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ],
                                  "uuid" => [ "string", "RFC 4122 UUID for file" ] },
                  'body'     => { "name" => [ "string", "new name for file" ] }
              }
            },
            { 'name'        => "delete",
              'request'     => $self->cgi->url."/".$self->name."/{UUID}",
              'description' => "delete indicated file from inbox",
              'example'     => [ 'curl -X DELETE -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/cfb3d9e1-c9ba-4260-95bf-e410c57b1e49"',
                                 "delete file 'sequences.fastq' from user inbox, auth is required" ],
              'method'      => "DELETE",
              'type'        => "synchronous",
              'attributes'  => $self->{base_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ],
                                  "uuid" => [ "string", "RFC 4122 UUID for file" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "file_info",
              'request'     => $self->cgi->url."/".$self->name."/info/{UUID}",
              'description' => "get basic file info - returns results and updates shock node",
              'example'     => [ 'curl -X GET -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/info/cfb3d9e1-c9ba-4260-95bf-e410c57b1e49"',
                                 "get basic info for file with given id in user inbox, auth is required" ],
              'method'      => "GET",
              'type'        => "synchronous",
              'attributes'  => $self->{stat_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ],
                                  "uuid" => [ "string", "RFC 4122 UUID for file" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "validate_metadata",
              'request'     => $self->cgi->url."/".$self->name."/validate/{UUID}",
              'description' => "validate metadata spreadsheet in inbox",
              'example'     => [ 'curl -X GET -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/validate/cfb3d9e1-c9ba-4260-95bf-e410c57b1e49"',
                                 "validate metadata file with given id in user inbox, auth is required" ],
              'method'      => "GET",
              'type'        => "synchronous",
              'attributes'  => $self->{base_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ],
                                  "uuid" => [ "string", "RFC 4122 UUID for file" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "seq_stats",
              'request'     => $self->cgi->url."/".$self->name."/stats/{UUID}",
              'description' => "runs sequence stats on file in user inbox - submits AWE job",
              'example'     => [ 'curl -X GET -H "auth: auth_key" "'.$self->cgi->url."/".$self->name.'/stats/cfb3d9e1-c9ba-4260-95bf-e410c57b1e49"',
                                 "runs seq stats on file with given id in user inbox, auth is required" ],
              'method'      => "GET",
              'type'        => "asynchronous",
              'attributes'  => $self->{id_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ],
                                  "uuid" => [ "string", "RFC 4122 UUID for sequence file" ] },
                  'body'     => {}
              }
            },
            { 'name'        => "sff_to_fastq",
              'request'     => $self->cgi->url."/".$self->name."/sff2fastq",
              'description' => "create fastq file from sff file - submits AWE job",
              'example'     => [ 'curl -X POST -H "auth: auth_key" -F "sff_file=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" "'.$self->cgi->url."/".$self->name.'/sff2fastq"',
                                 "create fastq file from sff file with given id in user inbox, auth is required" ],
              'method'      => "POST",
              'type'        => "asynchronous",
              'attributes'  => $self->{id_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => { "sff_file" => [ "string", "RFC 4122 UUID for sff file" ] }
              }
            },
            { 'name'        => "demultiplex",
              'request'     => $self->cgi->url."/".$self->name."/demultiplex",
              'description' => "demultiplex seq file with barcode file - submits AWE job",
              'example'     => [ 'curl -X POST -H "auth: auth_key" -F "seq_file=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" -F "barcode_file=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" "'.$self->cgi->url."/".$self->name.'/demultiplex"',
                                 "demultiplex seq file with barcode file for given ids in user inbox, auth is required" ],
              'method'      => "POST",
              'type'        => "asynchronous",
              'attributes'  => $self->{id_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => { "seq_file"      => [ "string", "RFC 4122 UUID for sequence file" ],
                                  "barcode_file"  => [ "string", "RFC 4122 UUID for barcode file" ] }
              }
            },
            { 'name'        => "pair_join",
              'request'     => $self->cgi->url."/".$self->name."/pairjoin",
              'description' => "merge overlapping paired-end fastq files - submits AWE job",
              'example'     => [ 'curl -X POST -H "auth: auth_key" -F "retain=1" -F "pair_file_1=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" -F "pair_file_2=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" "'.$self->cgi->url."/".$self->name.'/pairjoin"',
                                 "merge overlapping paired-end fastq files for given ids, retain non-overlapping pairs" ],
              'method'      => "POST",
              'type'        => "asynchronous",
              'attributes'  => $self->{id_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => { "pair_file_1" => [ "string", "RFC 4122 UUID for pair 1 file" ],
                                  "pair_file_2" => [ "string", "RFC 4122 UUID for pair 2 file" ],
                                  "output"      => [ "string", "prefix for output file, default is 'pair_file_1'_'pair_file_2'" ],
                                  "retain"      => [ "boolean", "If true retain non-overlapping sequences, default is false" ] }
              }
            },
            { 'name'        => "pair_join_demultiplex",
              'request'     => $self->cgi->url."/".$self->name."/pairjoin_demultiplex",
              'description' => "merge overlapping paired-end fastq files and demultiplex based on index file - submits AWE job",
              'example'     => [ 'curl -X POST -H "auth: auth_key" -F "pair_file_1=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" -F "pair_file_2=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" -F "index_file=cfb3d9e1-c9ba-4260-95bf-e410c57b1e49" "'.$self->cgi->url."/".$self->name.'/pairjoin_demultiplex"',
                                 "merge overlapping paired-end fastq files then demultiplex with index file, for given ids" ],
              'method'      => "POST",
              'type'        => "asynchronous",
              'attributes'  => $self->{id_attr},
              'parameters'  => {
                  'options'  => {},
                  'required' => { "auth" => [ "string", "unique string of text generated by MG-RAST for your account" ] },
                  'body'     => { "pair_file_1"   => [ "string", "RFC 4122 UUID for pair 1 file" ],
                                  "pair_file_2"   => [ "string", "RFC 4122 UUID for pair 2 file" ],
                                  "index_file"    => [ "string", "RFC 4122 UUID for optional index (barcode) file" ],
                                  "barcode_count" => [ "int", "number of unique barcodes in index_file" ],
                                  "output"        => [ "string", "prefix for output file names, default is 'pair_file_1'_'pair_file_2'" ],
                                  "retain"        => [ "boolean", "If true retain non-overlapping sequences, default is false" ] }
              }
            }
        ]
    };
    $self->return_data($content);
}

# Override parent request function
sub request {
    my ($self) = @_;
    
    # must have auth
    if ($self->user) {
        # upload or view
        if (scalar(@{$self->rest}) == 0) {
            if ($self->method eq 'GET') {
                $self->view_inbox();
            } elsif ($self->method eq 'POST') {
                $self->upload_file();
            }
        } elsif (($self->method eq 'GET') && (scalar(@{$self->rest}) == 1)) {
            # view pending actions
            if ($self->rest->[0] eq 'pending') {
                $self->view_inbox_actions();
            }
            # view one file
            else {
                $self->view_inbox($self->rest->[0]);
            }    
        # inbox actions that don't run through AWE
        } elsif (($self->method eq 'GET') && (scalar(@{$self->rest}) > 1)) {
            if ($self->rest->[0] eq 'info') {
                $self->file_info($self->rest->[1]);
            } elsif ($self->rest->[0] eq 'validate') {
                $self->validate_metadata($self->rest->[1]);
            } elsif ($self->rest->[0] eq 'stats') {
                $self->seq_stats($self->rest->[1]);
            }
        # inbox actions that run through AWE
        } elsif (($self->method eq 'POST') && (scalar(@{$self->rest}) > 0)) {
            if ($self->rest->[0] eq 'sff2fastq') {
                $self->sff_to_fastq();
            } elsif ($self->rest->[0] eq 'demultiplex') {
                $self->demultiplex();
            } elsif ($self->rest->[0] eq 'pairjoin') {
                $self->pair_join();
            } elsif ($self->rest->[0] eq 'pairjoin_demultiplex') {
                $self->pair_join(1);
            }
        # deleting from inbox
        } elsif (($self->method eq 'DELETE') && (scalar(@{$self->rest}) == 1)) {
            $self->delete_file($self->rest->[0]);
        # rename file
        } elsif (($self->method eq 'PUT') && (scalar(@{$self->rest}) == 1)) {
            $self->rename_file($self->rest->[0]);
        }
    }
    $self->info();
}

sub file_info {
    my ($self, $uuid) = @_;
    my ($node, $err_msg) = $self->get_file_info($uuid, undef, $self->token, $self->user_auth);
    $self->return_data({
        id         => 'mgu'.$self->user->_id,
        user       => $self->user->login,
        status     => $err_msg ? $err_msg : $node->{file}{name}." ($uuid) uploaded / updated",
        stats_info => $node->{attributes}{stats_info},
        timestamp  => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub validate_metadata {
    my ($self, $uuid) = @_;
    
    my $user_id = 'mgu'.$self->user->_id;
    my $response = {
        id        => $user_id,
        user      => $self->user->login,
        status    => "",
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    }
    my ($is_valid, $data, $log, $bar_id, $bar_count) = $self->metadata_validation($uuid, 1, 1, $self->token, $self->user_auth);
    if ($is_valid) {
        $response->{status} = "valid metadata";
        if ($bar_id && $bar_count) {
            $response->{barcode_file} = $bar_id;
            $response->{barcode_count} = $bar_count;
        }
    } else {
        $response->{status} = "invalid metadata";
        $response->{error} = ($data && (@$data > 0)) ? $data : $log;
    }
    $self->return_data($response);
}

sub seq_stats {
    my ($self, $uuid) = @_;
    
    # get and validate file
    my $node = $self->node_from_inbox_id($uuid, $self->token, $self->user_auth);
    unless (exists $node->{attributes}{stats_info}) {
        ($node, undef) = $self->get_file_info(undef, $node, $self->token, $self->user_auth);
    }
    my $user_id = 'mgu'.$self->user->_id;
    my $file_type = $self->seq_type_from_node($node);
    my $response = {
        id        => $user_id,
        user      => $self->user->login,
        status    => $node->{file}{name}." ($uuid) sequence stats computation",
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    };
    if (exists($node->{attributes}{data_type}) && ($node->{attributes}{data_type} eq "sequence")) {
        $response->{status} .= " has already been ran";
        $self->return_data($response);
    }
    
    # Do template replacement of MG-RAST's AWE workflow for sequence stats
    my $info = {
        shock_url    => $Conf::shock_url,
        job_name     => $user_id.'_seqstats',
        file_type    => $file_type,
        user_id      => $user_id,
        clientgroups => $Conf::mgrast_inbox_clientgroups,
        seq_file_id  => $node->{id},
        seq_file     => $node->{file}{name}
    };
    my $job = $self->submit_awe_template($info, $Conf::mgrast_seq_stats_workflow, $self->token, $self->user_auth);
    $self->add_node_action($node, $job, 'stats');
    
    # return data
    $response->{awe_id} = $Conf::awe_url.'/job/'.$job->{id};
    $response->{status} .= " is being run";
    $self->return_data($response);
}

sub sff_to_fastq {
    my ($self) = @_;

    # get and validate sequence file
    my $uuid = $self->cgi->param('sff_file') || "";
    unless ($uuid) {
        $self->return_data( {"ERROR" => "this request type requires the sff_file parameter"}, 400 );
    }
    my $node = $self->node_from_inbox_id($uuid, $self->token, $self->user_auth);
    unless (exists $node->{attributes}{stats_info}) {
        ($node, undef) = $self->get_file_info(undef, $node, $self->token, $self->user_auth);
    }
    unless (exists($node->{attributes}{stats_info}{file_type}) && ($node->{attributes}{stats_info}{file_type} eq "sff")) {
        $self->return_data( {"ERROR" => $uuid." (".$node->{file}{name}.") is not a sff format file"}, 400 );
    }
    
    # Do template replacement of MG-RAST's AWE workflow for sff to fastq
    my $user_id = 'mgu'.$self->user->_id;
    my $basename = fileparse($node->{file}{name}, qr/\.[^.]*/);
    my $info = {
        shock_url    => $Conf::shock_url,
        job_name     => $user_id.'_sff2fastq',
        user_id      => $user_id,
        user_name    => $self->user->login,
        user_email   => $self->user->email,
        clientgroups => $Conf::mgrast_inbox_clientgroups,
        sff_file_id  => $node->{id},
        sff_file     => $node->{file}{name},
        fastq_file   => $basename.'.fastq'
    };
    my $job = $self->submit_awe_template($info, $Conf::mgrast_sff_to_fastq_workflow, $self->token, $self->user_auth);
    $self->add_node_action($node, $job, 'sff2fastq');
    
    # return data
    $self->return_data({
        id        => $user_id,
        user      => $self->user->login,
        status    => $node->{file}{name}." ($uuid) sff to fastq is being run",
        awe_id    => $Conf::awe_url.'/job/'.$job->{id},
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub demultiplex {
    my ($self) = @_;
    
    # get and validate files
    my $seq_file = $self->cgi->param('seq_file') || "";
    my $bar_file = $self->cgi->param('barcode_file') || "";
    unless ($seq_file && $bar_file) {
        $self->return_data( {"ERROR" => "this request type requires both the seq_file and barcode_file parameters"}, 400 );
    }
    my $seq_node = $self->node_from_inbox_id($seq_file, $self->token, $self->user_auth);
    unless (exists $seq_node->{attributes}{stats_info}) {
        ($seq_node, undef) = $self->get_file_info(undef, $seq_node, $self->token, $self->user_auth);
    }
    my $bar_node = $self->node_from_inbox_id($bar_file, $self->token, $self->user_auth);
    unless (exists $bar_node->{attributes}{stats_info}) {
        ($bar_node, undef) = $self->get_file_info(undef, $bar_node, $self->token, $self->user_auth);
    }
    my $seq_type = $self->seq_type_from_node($seq_node);
    
    # download barcode file to get number and names of barcoded pieces
    my $barfiles = $self->get_barcode_files($bar_node->{id}, $self->token, $self->user_auth);
    
    # build awf parts for output / seq stats
    my $num = 0;
    my $shock_url = $Conf::shock_url;
    my $output_text = "";
    my $seq_stats_text = ""
    foreach my $fname (@$barfiles) {
        $num += 1;
        $output_text .= qq(
        "$fname.$seq_type": {
            "host": "$shock_url",
            "node": "-",
            "attrfile": "userattr.json"
        },);
        $seq_stats_text .= $self->seq_stats_task("0", $num, $fname, $seq_type);
    }
    chop($output_text);
    
    # Do template replacement of MG-RAST's AWE workflow for demultiplex
    my $user_id = 'mgu'.$self->user->_id;
    my $info = {
        shock_url    => $shock_url,
        job_name     => $user_id.'_demultiplex',
        user_id      => $user_id,
        user_name    => $self->user->login,
        user_email   => $self->user->email,
        clientgroups => $Conf::mgrast_inbox_clientgroups,
        file_type    => $seq_type,
        seq_file_id  => $seq_node->{id},
        seq_file     => $seq_node->{file}{name},
        bar_file_id  => $bar_node->{id},
        bar_file     => $bar_node->{file}{name},
        outputs      => $output_text,
        seq_stats    => $seq_stats_text
    };
    my $job = $self->submit_awe_template($info, $Conf::mgrast_demultiplex_workflow, $self->token, $self->user_auth);
    $self->add_node_action($seq_node, $job, 'demultiplex');
    $self->add_node_action($bar_node, $job, 'demultiplex');
    
    $self->return_data({
        id        => $user_id,
        user      => $self->user->login,
        status    => $seq_node->{file}{name}." ($seq_file) demultiplex is being run",
        awe_id    => $Conf::awe_url.'/job/'.$job->{id},
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub pair_join {
    my ($self, $demultiplex) = @_;
    
    # get and validate sequence files
    my $pair1_file = $self->cgi->param('pair_file_1') || "";
    my $pair2_file = $self->cgi->param('pair_file_2') || "";
    unless ($pair1_file && $pair2_file) {
        $self->return_data( {"ERROR" => "this request type requires both the pair_file_1 and pair_file_2 parameters"}, 400 );
    }
    my $pair1_node = $self->node_from_inbox_id($pair1_file, $self->token, $self->user_auth);
    unless (exists $pair1_node->{attributes}{stats_info}) {
        ($pair1_node, undef) = $self->get_file_info(undef, $pair1_node, $self->token, $self->user_auth);
    }
    my $pair2_node = $self->node_from_inbox_id($pair2_file, $self->token, $self->user_auth);
    unless (exists $pair2_node->{attributes}{stats_info}) {
        ($pair2_node, undef) = $self->get_file_info(undef, $pair2_node, $self->token, $self->user_auth);
    }
    my $p1_type = $self->seq_type_from_node($pair1_node);
    my $p2_type = $self->seq_type_from_node($pair2_node);
    unless (($p1_type eq 'fastq') && ($p2_type eq 'fastq')) {
        $self->return_data( {"ERROR" => "both input sequence files must be fastq format"}, 400 );
    }
    
    # Do template replacement of MG-RAST's AWE workflow for pairjoin
    my $user_id = 'mgu'.$self->user->_id;
    my $output  = $self->cgi->param('output') || $pair1_node->{file}{name}."_".$pair2_node->{file}{name};
    my $info = {
        shock_url    => $Conf::shock_url,
        user_id      => $user_id,
        user_name    => $self->user->login,
        user_email   => $self->user->email,
        clientgroups => $Conf::mgrast_inbox_clientgroups,
        p1_file_id   => $pair1_node->{id},
        p1_file      => $pair1_node->{file}{name},
        p2_file_id   => $pair2_node->{id},
        p2_file      => $pair2_node->{file}{name},
        retain       => $self->cgi->param('retain') ? "" : "-j ",
        out_file     => $output
    };
    my $job = undef;
    my $status = "";
    # do pair-join with demultiplex
    if ($demultiplex) {
        # validate extra options
        my $shock_url  = $Conf::shock_url;
        my $index_file = $self->cgi->param('index_file') || "";
        my $bc_count   = $self->cgi->param('barcode_count') || 0;
        unless ($index_file) {
            $self->return_data( {"ERROR" => "this request type requires the index_file parameter"}, 400 );
        }
        if ($bc_count < 2) {
            $self->return_data( {"ERROR" => "barcode_count value must be greater than 1"}, 400 );
        }
        my $index_node = $self->node_from_inbox_id($index_file, $self->token, $self->user_auth);
        unless (exists $index_node->{attributes}{stats_info}) {
            ($index_node, undef) = $self->get_file_info(undef, $index_node, $self->token, $self->user_auth);
        }
        # update template info
        $status = "pair join and demultiplex is being run on files: ".$pair1_node->{id}.", ".$pair2_node->{id}.", ".$index_node->{id};
        $info->{job_name}   = $user_id.'_pairjoin_demultiplex';
        $info->{index_file} = $index_node->{file}{name};
        $info->{index_id}   = $index_node->{id};
        $info->{outputs}    = "";
        $info->{seq_stats}  = "";
        # build awf parts for output / seq stats
        my $num = 3;
        my @outfiles = map { $output.".".$_.".fastq" } (1..$bc_count);
        push @outfiles, "nobarcode.".$output.".join.fastq";
        foreach my $fname (@outfiles) {
            $num += 1;
            $info->{outputs} .= qq(
            "$fname": {
                "host": "$shock_url",
                "node": "-",
                "attrfile": "userattr.json"
            },);
            $info->{seq_stats} .= $self->seq_stats_task("3", $num, $fname, "fastq");
        }
        chop($info->{outputs});
        $job = $self->submit_awe_template($info, $Conf::mgrast_pair_join_demultiplex_workflow, $self->token, $self->user_auth);
        $self->add_node_action($pair1_node, $job, 'pairjoin_demultiplex');
        $self->add_node_action($pair2_node, $job, 'pairjoin_demultiplex');
        $self->add_node_action($pair2_node, $job, 'pairjoin_demultiplex');
    }
    # do pair-join only
    else {
        $status = "pair join is being run on files: ".$pair1_node->{id}.", ".$pair2_node->{id};
        $info->{job_name} = $user_id.'_pairjoin';
        $job = $self->submit_awe_template($info, $Conf::mgrast_pair_join_workflow, $self->token, $self->user_auth);
        $self->add_node_action($pair1_node, $job, 'pairjoin');
        $self->add_node_action($pair2_node, $job, 'pairjoin');
    }
    
    $self->return_data({
        id        => $user_id,
        user      => $self->user->login,
        status    => $status,
        awe_id    => $Conf::awe_url.'/job/'.$job->{id},
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub view_inbox {
    my ($self, $uuid) = @_;

    my $user_id = 'mgu'.$self->user->_id;
    # get inbox
    my $inbox = [];
    if ($uuid) {
        $inbox = [ $self->node_from_inbox_id($uuid, $self->token, $self->user_auth) ];
    } else {
        $inbox = $self->get_shock_query({'type' => 'inbox', 'id' => $user_id}, $self->token, $self->user_auth);
    }
    # process inbox
    my $files = [];
    foreach my $node (@$inbox) {
        my $info = {
            'id'        => $node->{id},
            'filename'  => $node->{file}{name},
            'filesize'  => $node->{file}{size},
            'checksum'  => $node->{file}{checksum}{md5},
            'timestamp' => $node->{created_on}
        };
        # get file_info / compute if missing
        unless (exists $node->{attributes}{stats_info}) {
            ($node, undef) = $self->get_file_info(undef, $node, $self->token, $self->user_auth);
        }
        $info->{stats_info} = $node->{attributes}{stats_info};
        # check if any pending actions
        $self->update_node_actions($node);
        $info->{actions} = $node->{attributes}{actions};
        push @$files, $info;
    }
    $self->return_data({
        id        => $user_id,
        user      => $self->user->login,
        timestamp => strftime("%Y-%m-%dT%H:%M:%S", gmtime),
        files     => $files,
        url       => $self->cgi->url."/".$self->name
    });
}

sub view_inbox_actions {
    my ($self) = @_;

    my $jobs = [];
    my $user_id = 'mgu'.$self->user->_id;
    my $params = {
        "info.user" => [$user_id],
        "info.clientgroups" => ["mgrast_inbox"]
    };
    my $requestedStates = [];
    foreach my $state (@{$self->{states}}) {
        if ($self->cgi->param($state)) {
            push(@$requestedStates, $state);
        }
    }
    if (scalar(@$requestedStates)) {
        $params->{state} = $requestedStates;
    }
    $self->return_data($self->get_awe_query($params, $self->token, "mgrast"));
}

sub upload_file {
    my ($self) = @_;

    my $fn = $self->cgi->param('upload');
    if ($fn) {
        if ($fn !~ /^[\w\d_\.-]+$/) {
            $self->return_data({"ERROR" => "Invalid parameters, filename allows only word, underscore, dash (-), dot (.), and number characters"}, 400);
        }
        my $fh = $self->cgi->upload('upload');
        if (defined $fh) {
            # POST upload content to shock using file handle
            # data POST, not form
            my $response = undef;
            my $io_handle = $fh->handle;
            eval {
                my $post = HTTP::Request::StreamingUpload->new(
                    POST    => $Conf::shock_url.'/node',
                    fh      => $io_handle,
                    headers => HTTP::Headers->new(
                        'Content_Type' => 'application/octet-stream',
                        'Authorization' => $self->user_auth.' '.$self->token
                    )
                );
                my $req = LWP::UserAgent->new->request($post);
                $response = $self->json->decode( $req->content );
            };
            if ($@ || (! ref($response))) {
                $self->return_data({"ERROR" => "Unable to connect to Shock server"}, 507);
            } elsif (exists($response->{error}) && $response->{error}) {
                $self->return_data({"ERROR" => "Unable to POST to Shock: ".$response->{error}[0]}, $response->{status});
            }
            # PUT file name to node
            my $node_id = $response->{data}{id};
            my $node = $self->update_shock_node_file_name($node_id, "".$fn, $self->token, $self->user_auth);
            unless ($node && ($node->{id} eq $node_id)) {
                $self->return_data({"ERROR" => "storing object failed - unable to set file name"}, 507);
            }
            my $attr = {
                type  => 'inbox',
                id    => 'mgu'.$self->user->_id,
                user  => $self->user->login,
                email => $self->user->email
            };
            # PUT attributes to node
            $node = $self->update_shock_node($node_id, $attr, $self->token, $self->user_auth);
            # get / return file info
            $self->file_info($node_id);
        } else {
            $self->return_data( {"ERROR" => "storing object failed - could not obtain filehandle"}, 507 );
        }
    } else {
        $self->return_data( {"ERROR" => "invalid parameters, requires filename and data"}, 400 );
    }
}

sub delete_file {
    my ($self, $uuid) = @_;
    # check that no actions are being performed
    my $node = $self->node_from_inbox_id($uuid, $self->token, $self->user_auth);
    if (exists $node->{attributes}{actions}) {
        foreach my $act (@{$node->{attributes}{actions}}) {
            if (($act->{status} eq 'queued') || ($act->{status} eq 'in-progress')) {
                $self->return_data( {"ERROR" => "unable to delete file, ".$act->{name}." is ".$act->{status}}, 500 );
            }
        }
    }
    $self->delete_shock_node($uuid, $self->token, $self->user_auth);
    $self->return_data({
        id         => 'mgu'.$self->user->_id,
        user       => $self->user->login,
        status     => $node->{file}{name}." ($uuid) deleted",
        timestamp  => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub rename_file {
    my ($self, $uuid) = @_;
    my $name = $self->cgi->param('name') || "";
    unless ($name) {
        $self->return_data( {"ERROR" => "missing 'name' parameter"}, 400 );
    }
    my $node = $self->node_from_inbox_id($uuid, $auth, $authPrefix);
    my $attr = $node->{attributes};
    $self->update_shock_node_file_name($uuid, $name, $self->token, $self->user_auth);
    if (exists($attr->{stats_info}) && exists($attr->{stats_info}{file_name})) {
        $attr->{stats_info}{file_name} = $name;
        $node = $self->update_shock_node($uuid, $attr, $self->token, $self->user_auth);
    }
    $self->return_data({
        id         => 'mgu'.$self->user->_id,
        user       => $self->user->login,
        status     => $name." ($uuid) renamed",
        timestamp  => strftime("%Y-%m-%dT%H:%M:%S", gmtime)
    });
}

sub add_node_action {
    my ($self, $node, $job, $name) = @_;
    
    my $attr = $node->{attributes};
    my $actions = [];
    if (exists $attr->{actions}) {
        $actions = $attr->{actions};
    }
    push @$actions, {
        id => $job->{id},
        name => $name,
        status => ($job->{state} eq 'init') ? 'queued' : $job->{state},
        start => $job->{info}{submittime}
    };
    $attr->{actions} = $actions;
    $self->update_shock_node($node->{id}, $attr, $self->token, $self->user_auth);
}

sub update_node_actions {
    my ($self, $node) = @_;
    
    # get actions
    my $attr = $node->{attributes};
    my $new_actions = [];
    my $old_actions = [];
    if (exists $attr->{actions}) {
        $old_actions = $attr->{actions};
    }
    # check and update
    foreach my $act (@$old_actions) {
        # do nothing with completed
        if ($act->{status} eq 'completed') {
            push @$new_actions, $act;
        } else {
            my $job = $self->get_awe_job($act->{id}, $self->token, $self->user_auth);
            # drop it if deleted
            if ($job->{state} ne 'deleted') {
                $act->{status} = ($job->{state} eq 'init') ? 'queued' : $job->{state};
                push @$new_actions, $act;
            }
        }
    }
    # update node
    $attr->{actions} = $new_actions;
    $self->update_shock_node($node->{id}, $attr, $self->token, $self->user_auth);
}

sub seq_stats_task {
    my ($depend, $num, $fname, $seq_type) = @_;
    my $shock_url = $Conf::shock_url;
    return qq(,
    {
        "cmd": {
            "args": "-input=\@$fname.$seq_type -input_json=input_attr.json -output_json=output_attr.json -type=$seq_type",
            "description": "sequence stats",
            "name": "awe_seq_length_stats.pl",
            "environ" : {
                "public" : { "PERL5LIB" : "/root/pipeline/lib:/root/pipeline/conf" }
            }
        },
        "dependsOn": ["$depend"],
        "inputs": {
            "$fname.$seq_type": {
                "host": "$shock_url",
                "origin": "$depend",
                "node": "-",
                "attrfile": "input_attr.json"
            }
        },
        "outputs": {
            "$fname.$seq_type": {
                "host": "$shock_url",
                "origin": "$depend",
                "node": "-",
                "type": "update",
                "attrfile": "output_attr.json"
            }
        },
        "taskid": "$num",
        "totalwork": 1
    });
}

1;
